<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>bytecodecompiler.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#pragma once

#include "bytecodecompiler.hpp"
#include "randomxparams.hpp"
#include "reciprocal.hpp"
#include "sse.hpp"

namespace modernRX {
    namespace {
        constexpr uint32_t Scratchpad_L1_Mask{ (Rx_Scratchpad_L1_Size - 1) &amp; ~7 }; // L1 cache 8-byte alignment mask.
        constexpr uint32_t Scratchpad_L2_Mask{ (Rx_Scratchpad_L2_Size - 1) &amp; ~7 }; // L2 cache 8-byte alignment mask.
        constexpr uint32_t Scratchpad_L3_Mask{ (Rx_Scratchpad_L3_Size - 1) &amp; ~7 }; // L3 cache 8-byte alignment mask.

        void setJmpPoint(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const uint32_t reg_idx, const uint32_t instr_idx);

        template&lt;int Byte, typename Val&gt;
<span style = "background-color:#dfd">        [[nodiscard]] constexpr int8_t b(const Val&amp; v) noexcept {</span>
            static_assert(Byte &lt; sizeof(Val));
<span style = "background-color:#dfd">            return *(reinterpret_cast&lt;const int8_t*&gt;(&amp;v) + Byte);
        }</span>
    }

    using namespace assembler;
    using namespace assembler::registers;

<span style = "background-color:#dfd">    void iaddrs_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        constexpr uint8_t Displacement_Reg_Idx{ 5 };
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>
        
<span style = "background-color:#dfd">        const auto scale{ 64 * instr.modShift() };
        const auto index{ 8 * src_register };
        const auto base{ dst_register };</span>

<span style = "background-color:#dfd">        if (dst_register == Displacement_Reg_Idx) {
            const auto imm{ instr.imm32 };
            asmb.inject(char_array(</span>
                /* LEA */ 0x4f, 0x8d, 0xac, scale | index | base, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm)
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* LEA */ 0x4f, 0x8d, 0x04 + 8 * dst_register, scale | index | base
            ));
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void iaddm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto offset{ instr.imm32 &amp; Scratchpad_L3_Mask };
            asmb.inject(char_array(</span>
                /* ADD */ 0x4c, 0x03, 0x86 + 8 * dst_register, b&lt;0&gt;(offset), b&lt;1&gt;(offset), b&lt;2&gt;(offset), b&lt;3&gt;(offset)
            ));
<span style = "background-color:#dfd">        } else {
            const auto imm{ instr.imm32 };
            const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };</span>

<span style = "background-color:#dfd">            if (src_register != RSP.idx) {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x80 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* ADD */ 0x4c, 0x03, 0x04 + 8 * dst_register, 0x06
                ));
<span style = "background-color:#dfd">            } else {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x80 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* ADD */ 0x4c, 0x03, 0x04 + 8 * dst_register, 0x06
                ));
            }
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void isubr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto imm{ static_cast&lt;int32_t&gt;(instr.imm32) };
            asmb.inject(char_array(</span>
                /* SUB */ 0x49, 0x81, 0xe8 + dst_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm)
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* SUB */ 0x4d, 0x29, 0xc0 + dst_register + 8 * src_register
            ));
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void isubm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto offset{ instr.imm32 &amp; Scratchpad_L3_Mask };
            asmb.inject(char_array(</span>
                /* SUB */ 0x4c, 0x2b, 0x86 + 8 * dst_register, b&lt;0&gt;(offset), b&lt;1&gt;(offset), b&lt;2&gt;(offset), b&lt;3&gt;(offset)
            ));
<span style = "background-color:#dfd">        } else {
            const auto imm{ instr.imm32 };
            const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };</span>

<span style = "background-color:#dfd">            if (src_register != RSP.idx) {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x80 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* SUB */ 0x4c, 0x2b, 0x04 + 8 * dst_register, 0x06
                ));
<span style = "background-color:#dfd">            } else {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x80 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* SUB */ 0x4c, 0x2b, 0x04 + 8 * dst_register, 0x06
                ));
            }
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void imulr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto imm{ static_cast&lt;int32_t&gt;(instr.imm32) };
            asmb.inject(char_array(</span>
                /* IMUL */ 0x4d, 0x69, 0xc0 + 9 * dst_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm)
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* IMUL */ 0x4d, 0x0f, 0xaf, 0xc0 + 8 * dst_register + src_register
            ));
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void imulm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto offset{ instr.imm32 &amp; Scratchpad_L3_Mask };
            asmb.inject(char_array(</span>
                /* IMUL */ 0x4c, 0x0f, 0xaf, 0x86 + 8 * dst_register, b&lt;0&gt;(offset), b&lt;1&gt;(offset), b&lt;2&gt;(offset), b&lt;3&gt;(offset)
            ));
<span style = "background-color:#dfd">        } else {
            const auto imm{ instr.imm32 };
            const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };</span>

<span style = "background-color:#dfd">            if (src_register != RSP.idx) {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x88 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x81, 0xe1, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* IMUL */ 0x4c, 0x0f, 0xaf, 0x04 + 8 * dst_register, 0x0e
                ));
<span style = "background-color:#dfd">            } else {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x88 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x81, 0xe1, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* IMUL */ 0x4c, 0x0f, 0xaf, 0x04 + 8 * dst_register, 0x0e
                ));
            }
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void imulhr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
            /* MULH */ 0x49, 0xf7, 0xe0 + src_register,
            /* MOV */ 0x49, 0x89, 0xd0 + dst_register
        ));

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void imulhm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto offset{ instr.imm32 &amp; Scratchpad_L3_Mask };
            asmb.inject(char_array(</span>
                /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register, 
                /* MULH */ 0x48, 0xf7, 0xa6, b&lt;0&gt;(offset), b&lt;1&gt;(offset), b&lt;2&gt;(offset), b&lt;3&gt;(offset),
                /* MOV */ 0x49, 0x89, 0xd0 + dst_register
            ));
<span style = "background-color:#dfd">        } else {
            const auto imm{ instr.imm32 };
            const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };</span>

<span style = "background-color:#dfd">            if (src_register != RSP.idx) {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x88 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x81, 0xe1, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
                    /* MULH */ 0x48, 0xf7, 0x24, 0x0e,
                    /* MOV */ 0x49, 0x89, 0xd0 + dst_register
                ));
<span style = "background-color:#dfd">            } else {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x88 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x81, 0xe1, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
                    /* MULH */ 0x48, 0xf7, 0x24, 0x0e,
                    /* MOV */ 0x49, 0x89, 0xd0 + dst_register
                ));
            }
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void ismulhr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
            /* IMULH */ 0x49, 0xf7, 0xe8 + src_register,
            /* MOV */ 0x49, 0x89, 0xd0 + dst_register
        ));

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void ismulhm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto offset{ instr.imm32 &amp; Scratchpad_L3_Mask };
            asmb.inject(char_array(</span>
                /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
                /* IMULH */ 0x48, 0xf7, 0xae, b&lt;0&gt;(offset), b&lt;1&gt;(offset), b&lt;2&gt;(offset), b&lt;3&gt;(offset),
                /* MOV */ 0x49, 0x89, 0xd0 + dst_register
            ));
<span style = "background-color:#dfd">        } else {
            const auto imm{ instr.imm32 };
            const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };</span>

<span style = "background-color:#dfd">            if (src_register != RSP.idx) {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x88 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x81, 0xe1, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
                    /* IMULH */ 0x48, 0xf7, 0x2c, 0x0e,
                    /* MOV */ 0x49, 0x89, 0xd0 + dst_register
                ));
<span style = "background-color:#dfd">            } else {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x88 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x81, 0xe1, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* MOV */ 0x4c, 0x89, 0xc0 + 8 * dst_register,
                    /* IMULH */ 0x48, 0xf7, 0x2c, 0x0e,
                    /* MOV */ 0x49, 0x89, 0xd0 + dst_register
                ));
            }
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void inegr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        asmb.inject(char_array(</span>
            /* NEG */ 0x49, 0xf7, 0xd8 + dst_register
        ));
<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void ixorr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto imm{ static_cast&lt;int32_t&gt;(instr.imm32) };
            asmb.inject(char_array(</span>
                /* XOR */ 0x49, 0x81, 0xf0 + dst_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm)
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* XOR */ 0x4d, 0x31, 0xc0 + dst_register + 8 * src_register
            ));
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void ixorm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            const auto offset{ instr.imm32 &amp; Scratchpad_L3_Mask };
            asmb.inject(char_array(</span>
                /* XOR */ 0x4c, 0x33, 0x86 + 8 * dst_register, b&lt;0&gt;(offset), b&lt;1&gt;(offset), b&lt;2&gt;(offset), b&lt;3&gt;(offset)
            ));
<span style = "background-color:#dfd">        } else {
            const auto imm{ instr.imm32 };
            const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };</span>
            
<span style = "background-color:#dfd">            if (src_register != RSP.idx) {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x80 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* XOR */ 0x4c, 0x33, 0x04 + 8 * dst_register, 0x06
                ));
<span style = "background-color:#dfd">            } else {
                asmb.inject(char_array(</span>
                    /* LEA */ 0x49, 0x8d, 0x80 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                    /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                    /* XOR */ 0x4c, 0x33, 0x04 + 8 * dst_register, 0x06
                ));
            }
        }

<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void irorr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            if (const auto imm = instr.imm32 % 64; imm != 0) {
                asmb.inject(char_array(</span>
                    /* ROR */ 0x49, 0xc1, 0xc8 + dst_register, b&lt;0&gt;(imm)
                ));
            }
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* MOV */ 0x4c, 0x89, 0xc1 + 8 * src_register,
                /* ROR */ 0x49, 0xd3, 0xc8 + dst_register
            ));
        }

        // Set even for rotate == 0.
<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void irolr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (dst_register == src_register) {
            if (const auto imm = instr.imm32 % 64; imm != 0) {
                asmb.inject(char_array(</span>
                    /* ROL */ 0x49, 0xc1, 0xc0 + dst_register, b&lt;0&gt;(imm)
                ));
            }
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* MOV */ 0x4c, 0x89, 0xc1 + 8 * src_register,
                /* ROL */ 0x49, 0xd3, 0xc0 + dst_register
            ));
        }

        // Set even for rotate == 0.
<span style = "background-color:#dfd">        setJmpPoint(asmb, reg_usage, dst_register, idx);
    }</span>

<span style = "background-color:#dfd">    void imulrcp_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (const auto imm = instr.imm32; imm != 0 &amp;&amp; !std::has_single_bit(imm)) {
            const auto rcp{ reciprocal(imm) };
            asmb.inject(char_array(</span>
                /* MOV */ 0x48, 0xb8, b&lt;0&gt;(rcp), b&lt;1&gt;(rcp), b&lt;2&gt;(rcp), b&lt;3&gt;(rcp), b&lt;4&gt;(rcp), b&lt;5&gt;(rcp), b&lt;6&gt;(rcp), b&lt;7&gt;(rcp),
                /* IMUL */ 0x4c, 0x0f, 0xaf, 0xc0 + 8 * dst_register
            ));
<span style = "background-color:#dfd">            setJmpPoint(asmb, reg_usage, dst_register, idx);</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void iswapr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (src_register != dst_register) {
            asmb.inject(char_array(</span>
                /* XCHG */ 0x4d, 0x87, 0xc0 + dst_register + 8 * src_register
            ));
<span style = "background-color:#dfd">            setJmpPoint(asmb, reg_usage, src_register, idx);
            setJmpPoint(asmb, reg_usage, dst_register, idx);</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void cbranch_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        constexpr uint32_t Condition_Mask{ (1 &lt;&lt; Rx_Jump_Bits) - 1 };
        const auto shift{ instr.modCond() + Rx_Jump_Offset };
        const auto mem_mask{ Condition_Mask &lt;&lt; shift };</span>

        static_assert(Rx_Jump_Offset &gt; 0, "Below simplification requires this assertion");
<span style = "background-color:#dfd">        int32_t imm{ static_cast&lt;int32_t&gt;(instr.imm32) | (1 &lt;&lt; shift) };
        imm &amp;= ~(1ULL &lt;&lt; (shift - 1)); // Clear the bit below the condition mask - this limits the number of successive jumps to 2.</span>

<span style = "background-color:#dfd">        const auto jmp_target{ reg_usage[dst_register] + 1 };
        const auto jmp_offset{ asmb.labelOffset(jmp_target) - 20 };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* ADD */ 0x49, 0x81, 0xc0 + dst_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
            /* TEST */ 0x49, 0xf7, 0xc0 + dst_register, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
            /* JZ */  0x0f, 0x84, b&lt;0&gt;(jmp_offset), b&lt;1&gt;(jmp_offset), b&lt;2&gt;(jmp_offset), b&lt;3&gt;(jmp_offset)
        ));

<span style = "background-color:#dfd">        asmb.label&lt;false&gt;(idx + 1);
        for (auto&amp; reg : reg_usage) reg = idx; // Set all registers as used.
    }</span>

<span style = "background-color:#dfd">    void fswapr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* VSHUFPD */ 0xc5, 0xf9 - 8 * dst_register, 0xc6, 0xc0 + 9 * dst_register, 0x01
        ));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void faddr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Float_Register_Count };
        const uint8_t src_register{ 8 + instr.src_register % Float_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* VADDPD */ 0xc5, 0xf9 - 8 * src_register, 0x58, 0xc0 + 9 * dst_register
        ));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void faddm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t src_register{ instr.src_register % Int_Register_Count };
        const uint8_t f_dst_register{ instr.dst_register % Float_Register_Count };
        const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };
        const auto imm{ instr.imm32 };</span>

<span style = "background-color:#dfd">        if (src_register != RSP.idx) {
            asmb.inject(char_array(</span>
                /* LEA */ 0x49, 0x8d, 0x80 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* VCVTDQ2PD */ 0xc5, 0x7a, 0xe6, 0x24, 0x06,
                /* VADDPD */ 0xc5, 0x99, 0x58, 0xc0 + 9 * f_dst_register
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* LEA */ 0x49, 0x8d, 0x80 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* VCVTDQ2PD */ 0xc5, 0x7a, 0xe6, 0x24, 0x06,
                /* VADDPD */ 0xc5, 0x99, 0x58, 0xc0 + 9 * f_dst_register
            ));
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void fsubr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Float_Register_Count };
        const uint8_t src_register{ instr.src_register % Float_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* VSUBPD */ 0xc4, 0xc1, 0x79 - 8 * dst_register, 0x5c, 0xc0 + 8 * dst_register + src_register
        ));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void fsubm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t src_register{ instr.src_register % Int_Register_Count };
        const uint8_t f_dst_register{ instr.dst_register % Float_Register_Count };
        const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };
        const auto imm{ instr.imm32 };</span>

<span style = "background-color:#dfd">        if (src_register != RSP.idx) {
            asmb.inject(char_array(</span>
                /* LEA */ 0x49, 0x8d, 0x80 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* VCVTDQ2PD */ 0xc5, 0x7a, 0xe6, 0x24, 0x06,
                /* VSUBPD */ 0xc4, 0xc1, 0x79 - 8 * f_dst_register, 0x5c, 0xc4 + 8 * f_dst_register
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* LEA */ 0x49, 0x8d, 0x80 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* VCVTDQ2PD */ 0xc5, 0x7a, 0xe6, 0x24, 0x06,
                /* VSUBPD */ 0xc4, 0xc1, 0x79 - 8 * f_dst_register, 0x5c, 0xc4 + 8 * f_dst_register
            ));
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void fscalr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Float_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* VPXOR */ 0xc5, 0x89, 0xef, 0xc0 + 9 * dst_register
        ));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void fmulr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Float_Register_Count };
        const uint8_t src_register{ instr.src_register % Float_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* VMULPD */ 0xc5, 0xb9 - 8 * src_register, 0x59, 0xe4 + 9 * dst_register
        ));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void fdivm_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t src_register{ instr.src_register % Int_Register_Count };
        const uint8_t f_dst_register{ instr.dst_register % Float_Register_Count };
        const auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };
        const auto imm{ instr.imm32 };</span>

<span style = "background-color:#dfd">        if (src_register != registers::RSP.idx) {
            asmb.inject(char_array(</span>
                /* VMOVDQU */ 0xc5, 0x7a, 0x6f, 0xaf, 0x18, 0x01, 0x00, 0x00,
                /* LEA */ 0x49, 0x8d, 0x80 + src_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* VCVTDQ2PD */ 0xc5, 0x7a, 0xe6, 0x24, 0x06,
                /* VPAND */ 0xc4, 0x41, 0x19, 0xdb, 0xe7,
                /* VPOR */ 0xc4, 0x41, 0x19, 0xeb, 0xe5,
                /* VDIVPD */ 0xc4, 0xc1, 0x59 - 8 * f_dst_register, 0x5e, 0xe4 + 8 * f_dst_register
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* VMOVDQU */ 0xc5, 0x7a, 0x6f, 0xaf, 0x18, 0x01, 0x00, 0x00,
                /* LEA */ 0x49, 0x8d, 0x80 + src_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* VCVTDQ2PD */ 0xc5, 0x7a, 0xe6, 0x24, 0x06,
                /* VPAND */ 0xc4, 0x41, 0x19, 0xdb, 0xe7,
                /* VPOR */ 0xc4, 0x41, 0x19, 0xeb, 0xe5,
                /* VDIVPD */ 0xc4, 0xc1, 0x59 - 8 * f_dst_register, 0x5e, 0xe4 + 8 * f_dst_register
            ));
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void fsqrtr_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Float_Register_Count };</span>

<span style = "background-color:#dfd">        asmb.inject(char_array(</span>
            /* VSQRTPD */ 0xc5, 0xf9, 0x51, 0xe4 + 9 * dst_register
        ));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void cfround_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t src_register{ instr.src_register % Int_Register_Count };</span>

<span style = "background-color:#dfd">        if (const auto imm{ instr.imm32 % 64 }; imm != 0) {
            asmb.inject(char_array(</span>
                /* MOV */ 0x4c, 0x89, 0xc0 + 8 * src_register,
                /* ROR */ 0x48, 0xc1, 0xc8, b&lt;0&gt;(imm),
                /* AND */ 0x48, 0x83, 0xe0, 0x03,
                /* ROL */ 0x48, 0xc1, 0xc0, 0x0d,
                /* OR */ 0x48, 0x0d, 0xc0, 0x9f, 0x00, 0x00,
                /* PUSH */ 0x50,
                /* LDMXCSR */ 0x0f, 0xae, 0x14, 0x24,
                /* POP */ 0x58
            ));
<span style = "background-color:#dfd">        } else {</span>
<span style = "background-color:#fdd">            asmb.inject(char_array(</span>
                /* MOV */ 0x4c, 0x89, 0xc0 + 8 * src_register,
                /* AND */ 0x48, 0x83, 0xe0, 0x03,
                /* ROL */ 0x48, 0xc1, 0xc0, 0x0d,
                /* OR */ 0x48, 0x0d, 0xc0, 0x9f, 0x00, 0x00,
                /* PUSH */ 0x50,
                /* LDMXCSR */ 0x0f, 0xae, 0x14, 0x24,
                /* POP */ 0x58
            ));
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void istore_cmpl(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const RxInstruction&amp; instr, const uint32_t idx) {
        const uint8_t dst_register{ instr.dst_register % Int_Register_Count };
        const uint8_t src_register{ instr.src_register % Int_Register_Count };
        const auto imm{ static_cast&lt;int32_t&gt;(instr.imm32) };
        constexpr uint32_t L3_Store_Condition{ 14 };</span>

<span style = "background-color:#dfd">        auto mem_mask{ instr.modMask() ? Scratchpad_L1_Mask : Scratchpad_L2_Mask };
        if (instr.modCond() &gt;= L3_Store_Condition) {
            mem_mask = Scratchpad_L3_Mask;</span>
        }

<span style = "background-color:#dfd">        if (dst_register != registers::RSP.idx) {
            asmb.inject(char_array(</span>
                /* LEA */ 0x49, 0x8d, 0x80 + dst_register, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* MOV */ 0x4c, 0x89, 0x04 + 8 * src_register, 0x06
            ));
<span style = "background-color:#dfd">        } else {
            asmb.inject(char_array(</span>
                /* LEA */ 0x49, 0x8d, 0x80 + dst_register, 0x24, b&lt;0&gt;(imm), b&lt;1&gt;(imm), b&lt;2&gt;(imm), b&lt;3&gt;(imm),
                /* AND */ 0x48, 0x25, b&lt;0&gt;(mem_mask), b&lt;1&gt;(mem_mask), b&lt;2&gt;(mem_mask), b&lt;3&gt;(mem_mask),
                /* MOV */ 0x4c, 0x89, 0x04 + 8 * src_register, 0x06
            ));
        }
<span style = "background-color:#dfd">    }</span>

    namespace {
        // Mark register as used by current instruction and set jump point to next instruction.
<span style = "background-color:#dfd">        void setJmpPoint(assembler::Context&amp; asmb, std::array&lt;int32_t, Int_Register_Count&gt;&amp; reg_usage, const uint32_t reg_idx, const uint32_t instr_idx) {
            reg_usage[reg_idx] = instr_idx;
            asmb.label&lt;false&gt;(instr_idx + 1);
        };</span>
    }
}</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>