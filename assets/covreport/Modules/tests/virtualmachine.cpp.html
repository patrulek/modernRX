<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>virtualmachine.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;utility&gt;

#include "aes1rhash.hpp"
#include "aes1rrandom.hpp"
#include "aes4rrandom.hpp"
#include "bytecodecompiler.hpp"
#include "hash.hpp"
#include "randomxparams.hpp"
#include "sse.hpp"
#include "virtualmachine.hpp"
#include "virtualmem.hpp"

#include "virtualmachineprogram.cpp"

namespace modernRX {
    namespace {
        constexpr uint32_t Scratchpad_L3_Mask64{ (Rx_Scratchpad_L3_Size - 1) &amp; ~63 }; // L3 cache 64-byte alignment mask.
        constexpr uint64_t Cache_Line_Size{ sizeof(DatasetItem) };
        constexpr uint64_t Cache_Line_Align_Mask{ (Rx_Dataset_Base_Size - 1) &amp; ~(Cache_Line_Size - 1) }; // Dataset 64-byte alignment mask.

        // Holds representation of register file used by VirtualMachine during program execution.
        // https://github.com/tevador/RandomX/blob/master/doc/specs.md#43-registers
        struct RegisterFile {
            std::array&lt;uint64_t, Int_Register_Count&gt; r{}; // Common integer registers. Source or destination of integer instructions. Can be used as address registers for scratchpad access.
            std::array&lt;intrinsics::xmm128d_t, Float_Register_Count&gt; f{}; // "Additive" registers. Destination of floating point addition and substraction instructions.
            std::array&lt;intrinsics::xmm128d_t, Float_Register_Count&gt; e{}; // "Multiplicative" registers. Destination of floating point multiplication, division and square root instructions.
            std::array&lt;intrinsics::xmm128d_t, Float_Register_Count&gt; a{}; // Read-only, fixed-value floating point registers. Source operand of any floating point instruction.
        };
    }

    // Holds RandomX program entropy and instructions: https://github.com/tevador/RandomX/blob/master/doc/specs.md#44-program-buffer
    // Initialized by AES-filled buffer. Must preserve order of fields.
    struct alignas(64) RxProgram {
        std::array&lt;uint64_t, 16&gt; entropy{};
        std::array&lt;RxInstruction, Rx_Program_Size&gt; instructions{};
    };
    static_assert(sizeof(RxProgram) == Rx_Program_Bytes_Size); // Size of random program is also used in different context. Make sure both values match.
    static_assert(offsetof(RxProgram, entropy) == 0);


    VirtualMachine::VirtualMachine() 
<span style = "background-color:#dfd">        : scratchpad(Rx_Scratchpad_L3_Size + sizeof(RegisterFile)) {
        jit = makeExecutable&lt;JITRxProgram&gt;(sizeof(Code_Buffer));
        std::memcpy(jit.get(), Code_Buffer.data(), sizeof(Code_Buffer));
        compiler.code_buffer = reinterpret_cast&lt;char*&gt;(jit.get()) + Program_Offset;
    }</span>

<span style = "background-color:#dfd">    void VirtualMachine::reset(BlockTemplate block_template, const_span&lt;DatasetItem&gt; dataset) {
        this-&gt;dataset = dataset;
        this-&gt;block_template = block_template;
    }</span>

<span style = "background-color:#dfd">    void VirtualMachine::execute(std::function&lt;void(const RxHash&amp;)&gt; callback) {
        blake2b::hash(seed, block_template.view());
        aes::fill1R(scratchpad.buffer(sizeof(RegisterFile), scratchpad.size() - sizeof(RegisterFile)), seed);</span>
        // RandomX requires specific float environment before executing any program.
        // This RAII object will set proper float flags on creation and restore its values on destruction. 
<span style = "background-color:#dfd">        const intrinsics::sse::FloatEnvironment fenv{};
        RxProgram program;
        constexpr uint64_t Dataset_Extra_Items{ Rx_Dataset_Extra_Size / sizeof(DatasetItem) };</span>
        static_assert(std::has_single_bit(Dataset_Extra_Items + 1));
        static_assert(Cache_Line_Size == 64);

<span style = "background-color:#dfd">        for (uint32_t i = 0; i &lt; Rx_Program_Count - 1; ++i) {
            generateProgram(program);
            compileProgram(program);</span>

<span style = "background-color:#dfd">            const auto dataset_offset{ (program.entropy[13] &amp; Dataset_Extra_Items) * Cache_Line_Size };
            const auto dataset_ptr{ reinterpret_cast&lt;uintptr_t&gt;(dataset.data()) + dataset_offset };</span>
            // https://github.com/tevador/RandomX/blob/master/doc/specs.md#462-loop-execution
            // Step 1-13.
<span style = "background-color:#dfd">            const auto jit_program{ reinterpret_cast&lt;JITRxProgram&gt;(jit.get()) };
            jit_program(0 /* deprecated */, reinterpret_cast&lt;uintptr_t&gt;(scratchpad.data()) + sizeof(RegisterFile),</span>
                        dataset_ptr, reinterpret_cast&lt;uintptr_t&gt;(&amp;program));
<span style = "background-color:#dfd">            blake2b::hash(seed, span_cast&lt;std::byte, sizeof(RegisterFile)&gt;(scratchpad.data()));
        }</span>

<span style = "background-color:#dfd">        generateProgram(program);
        compileProgram(program); </span>

        // https://github.com/tevador/RandomX/blob/master/doc/specs.md#462-loop-execution
        // Step 1-13.
<span style = "background-color:#dfd">        const auto dataset_offset{ (program.entropy[13] &amp; Dataset_Extra_Items) * Cache_Line_Size };
        const auto dataset_ptr{ reinterpret_cast&lt;uintptr_t&gt;(dataset.data()) + dataset_offset };
        const auto jit_program{ reinterpret_cast&lt;JITRxProgram&gt;(jit.get()) };
        jit_program(0 /* deprecated */, reinterpret_cast&lt;uintptr_t&gt;(scratchpad.data()) + sizeof(RegisterFile),</span>
            dataset_ptr, reinterpret_cast&lt;uintptr_t&gt;(&amp;program));

<span style = "background-color:#dfd">        aes::hash1R(span_cast&lt;std::byte, sizeof(RegisterFile::a)&gt;(scratchpad.data() + sizeof(RegisterFile) - sizeof(RegisterFile::a)), </span>
            span_cast&lt;std::byte, Rx_Scratchpad_L3_Size&gt;(scratchpad.data() + sizeof(RegisterFile)));
        
        RxHash output;
<span style = "background-color:#dfd">        blake2b::hash(output.buffer(), span_cast&lt;std::byte, sizeof(RegisterFile)&gt;(scratchpad.data()));
        callback(output);
        block_template.next();
    }</span>

<span style = "background-color:#dfd">    void VirtualMachine::generateProgram(RxProgram&amp; program) {
        aes::fill4R(span_cast&lt;std::byte&gt;(program), seed);</span>
        // Last 64 bytes of the program are now the new seed.
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void VirtualMachine::compileProgram(const RxProgram&amp; program) {
        compiler.reset();</span>

        // RDI = rf
        // RSI = scratchpad
        // RBP = dataset

        // Compile all instructions.
<span style = "background-color:#dfd">        for (uint32_t i = 0; i &lt; program.instructions.size(); ++i) {
            compiler.instr_offset[i] = compiler.code_size;
            const RxInstruction&amp; instr{ program.instructions[i] };
            (compiler.*LUT_Instr_Cmpl[instr.opcode])(instr, i);
        }</span>

<span style = "background-color:#dfd">        auto loop_finalization_offset{ 0 };</span>
        // Program size thresholds
        // Jmp to finalize registers.
<span style = "background-color:#dfd">        if (compiler.code_size &lt; Loop_Finalization_Offset_1 - Program_Offset - 5) {
            loop_finalization_offset = Loop_Finalization_Offset_1;</span>
<span style = "background-color:#fdd">        } else if (compiler.code_size &lt; Loop_Finalization_Offset_2 - Program_Offset - 5) {
            loop_finalization_offset = Loop_Finalization_Offset_2;
        } else if (compiler.code_size &lt; Max_Program_Size - 5) {
            loop_finalization_offset = Loop_Finalization_Offset_3;</span>
        } else {
            // do nothing; just let it pass through nops
        }

<span style = "background-color:#dfd">        if (loop_finalization_offset &gt; 0) {
            const int32_t jmp_offset{ loop_finalization_offset - compiler.code_size - Program_Offset - 5 };
            const uint8_t jmp{ 0xe9 };
            std::memcpy(compiler.code_buffer + compiler.code_size, &amp;jmp, sizeof(uint8_t));
            std::memcpy(compiler.code_buffer + compiler.code_size + 1, &amp;jmp_offset, sizeof(int32_t));
            compiler.code_size += 5;</span>
        }

        // Compile finalize registers.
        static_assert(Cache_Line_Align_Mask == 0x7FFF'FFC0);
        static_assert(std::has_single_bit(Cache_Line_Size));
        static_assert(Scratchpad_L3_Mask64 == 0x001F'FFC0);

<span style = "background-color:#dfd">        const uint8_t read_reg2 = static_cast&lt;uint8_t&gt;(0xc7 + 8 * (4 + ((program.entropy[12] &gt;&gt; 2) &amp; 1)));
        const auto rr2_offset{ 8 };
        std::memcpy(reinterpret_cast&lt;char*&gt;(jit.get()) + loop_finalization_offset + rr2_offset, &amp;read_reg2, sizeof(uint8_t));</span>

<span style = "background-color:#dfd">        const uint8_t read_reg3 = static_cast&lt;uint8_t&gt;(0xc7 + 8 * (6 + ((program.entropy[12] &gt;&gt; 3) &amp; 1)));
        const auto rr3_offset{ 11 };
        std::memcpy(reinterpret_cast&lt;char*&gt;(jit.get()) + loop_finalization_offset + rr3_offset, &amp;read_reg3, sizeof(uint8_t));</span>

<span style = "background-color:#dfd">        const uint8_t read_reg0 = static_cast&lt;uint8_t&gt;(0xc2 + 8 * (0 + ((program.entropy[12] &gt;&gt; 0) &amp; 1)));
        const auto rr0_offset{ 149 };
        std::memcpy(reinterpret_cast&lt;char*&gt;(jit.get()) + loop_finalization_offset + rr0_offset, &amp;read_reg0, sizeof(uint8_t));</span>

<span style = "background-color:#dfd">        const uint8_t read_reg1 = static_cast&lt;uint8_t&gt;(0xc2 + 8 * (2 + ((program.entropy[12] &gt;&gt; 1) &amp; 1)));
        const auto rr1_offset{ 152 };
        std::memcpy(reinterpret_cast&lt;char*&gt;(jit.get()) + loop_finalization_offset + rr1_offset, &amp;read_reg1, sizeof(uint8_t));
    }</span>
}</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>