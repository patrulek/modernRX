<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>virtualmem.hpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#pragma once

/*
* Wrapper over Windows virtual memory API.
* Used to allocate executable memory for JIT-compiled programs.
*/

#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include &lt;Windows.h&gt;

#include &lt;cstdint&gt;
#include &lt;format&gt;

#include "aliases.hpp"
#include "exception.hpp"
#include "heaparray.hpp"

namespace modernRX {
    template&lt;typename T&gt;
    inline constexpr bool is_vector_v = std::same_as&lt;T, std::vector&lt;typename T::value_type, typename T::allocator_type&gt; &gt;;

    template&lt;typename T&gt;
    inline constexpr bool is_spanable_v = std::is_constructible_v&lt;const_span&lt;typename T::value_type&gt;, T&gt;;

    template&lt;typename T&gt;
    requires is_spanable_v&lt;T&gt;
<span style = "background-color:#dfd">    [[nodiscard]] constexpr const_span&lt;typename T::value_type&gt; as_span(const T&amp; t) noexcept {
        return const_span&lt;typename T::value_type&gt;(t);
    }</span>

    // Allocates executable memory and returns a function pointer to it.
    // Type of the function pointer is specified by the template parameter.
    // The function pointer is wrapped in a unique_ptr with a custom deleter that will free allocated memory and data associated with program at destruction.
    // May throw if memory allocation or protection fails.
    // 
    // Function takes data as a parameter and prolongs its lifetime until the JIT-compiled function is destroyed.
    // Somewhat hacky, would be nice to find a better solution.
    template&lt;typename Fn, typename Code, typename Data&gt;
    requires is_vector_v&lt;Data&gt;
<span style = "background-color:#dfd">    [[nodiscard]] constexpr jit_function_ptr&lt;Fn&gt; makeExecutable(const Code&amp;&amp; code, Data&amp;&amp; data) {
        const auto code_size{ as_span(code).size_bytes() };</span>

        // Alloc buffer for writing code.
<span style = "background-color:#dfd">        auto buffer{ VirtualAlloc(nullptr, code_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) };
        if (buffer == nullptr) {</span>
<span style = "background-color:#fdd">            throw Exception(std::format("Failed to allocate memory with error: {:d}", GetLastError()));</span>
        }

<span style = "background-color:#dfd">        std::memcpy(buffer, code.data(), code_size);</span>

        // Protect from writing, but make code executable.
<span style = "background-color:#dfd">        DWORD dummy{};
        if (!VirtualProtect(buffer, code_size, PAGE_EXECUTE_READ, &amp;dummy)) {</span>
<span style = "background-color:#fdd">            const auto err{ GetLastError() };
            VirtualFree(buffer, 0, MEM_RELEASE); // Ignore error.
            throw Exception(std::format("Failed to protect memory with error: {:d}", err));</span>
        }

<span style = "background-color:#dfd">        return jit_function_ptr&lt;Fn&gt;(reinterpret_cast&lt;Fn*&gt;(buffer), [moved_data = std::move(data)](Fn* ptr) noexcept {
            VirtualFree(ptr, 0, MEM_RELEASE); // Ignore error.</span>
            // moved_data will be destroyed and release memory here automatically.
<span style = "background-color:#dfd">        });
    }</span>

    // Allocates executable memory that is also writeable (not protected).
    // Use for performance when code buffers are allocated and changed frequently.
    // May throw if memory allocation fails.
    template&lt;typename Fn&gt;
<span style = "background-color:#dfd">    [[nodiscard]] constexpr jit_function_ptr&lt;Fn&gt; makeExecutable(const size_t code_size) {</span>
        // Alloc buffer for writing code.
<span style = "background-color:#dfd">        const auto buffer{ VirtualAlloc(nullptr, code_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) };
        if (buffer == nullptr) {</span>
<span style = "background-color:#fdd">            throw Exception(std::format("Failed to allocate memory with error: {:d}", GetLastError()));</span>
        }

<span style = "background-color:#dfd">        return jit_function_ptr&lt;Fn&gt;(reinterpret_cast&lt;Fn*&gt;(buffer), [](Fn* ptr) noexcept {
            VirtualFree(ptr, 0, MEM_RELEASE); // Ignore error.           
        });
    }</span>
}</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>